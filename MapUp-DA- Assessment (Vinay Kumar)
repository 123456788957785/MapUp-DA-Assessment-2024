Python Section 1

Question 1: Reverse List by N Elements

def reverse_by_n_elements(lst, n):
    result = []
    for i in range(0, len(lst), n):
        # Reverse each chunk of size n manually without slicing
        chunk = lst[i:i+n]
        reversed_chunk = []
        for j in range(len(chunk)):
            reversed_chunk.insert(0, chunk[j])
        result.extend(reversed_chunk)
    return result

Explanation: The list is processed in chunks of n, and each chunk is reversed manually by inserting elements into a new list.

Question 2: Lists & Dictionaries

def group_by_length(lst):
    grouped = {}
    for word in lst:
        length = len(word)
        if length not in grouped:
            grouped[length] = []
        grouped[length].append(word)
    return dict(sorted(grouped.items()))

Explanation: A dictionary is built by using the string lengths as keys. The function then sorts the dictionary by the key values (i.e., string lengths).

Question 3: Flatten a Nested Dictionary

def flatten_dict(d, parent_key='', sep='.'):
    items = []
    for k, v in d.items():
        new_key = f"{parent_key}{sep}{k}" if parent_key else k
        if isinstance(v, dict):
            items.extend(flatten_dict(v, new_key, sep=sep).items())
        elif isinstance(v, list):
            for i, item in enumerate(v):
                items.extend(flatten_dict({f"{k}[{i}]": item}, parent_key, sep=sep).items())
        else:
            items.append((new_key, v))
    return dict(items)

Explanation: The function recursively processes nested dictionaries and lists, building new keys using dot notation and appending indices for list elements.

Question 4: Generate Unique Permutations

from itertools import permutations

def unique_permutations(lst):
    return list(map(list, set(permutations(lst))))

Explanation: Use itertools.permutations to generate all possible permutations and convert them to a set to ensure uniqueness.

Question 5: Find All Dates in a Text

import re

def find_all_dates(text):
    date_pattern = r'\b(?:\d{2}-\d{2}-\d{4}|\d{2}/\d{2}/\d{4}|\d{4}\.\d{2}\.\d{2})\b'
    return re.findall(date_pattern, text)

Explanation: This function uses regular expressions to match dates in the specified formats and returns all valid matches.

Question 6: Decode Polyline, Convert to DataFrame with Distances

import polyline
import pandas as pd
from haversine import haversine

def decode_polyline(polyline_str):
    coords = polyline.decode(polyline_str)
    df = pd.DataFrame(coords, columns=['latitude', 'longitude'])
    
    # Calculate distance using the Haversine formula
    df['distance'] = [0] + [haversine(df.iloc[i-1][['latitude', 'longitude']], df.iloc[i][['latitude', 'longitude']]) * 1000 for i in range(1, len(df))]
    return df

Explanation: The polyline is decoded, and distances between successive points are calculated using the Haversine formula.

Question 7: Matrix Rotation and Transformation

import numpy as np

def rotate_matrix_90(matrix):
    n = len(matrix)
    rotated = [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)]
    return rotated

def sum_matrix(matrix):
    n = len(matrix)
    result = []
    for i in range(n):
        row = []
        for j in range(n):
            row_sum = sum(matrix[i]) + sum([matrix[k][j] for k in range(n)]) - matrix[i][j]
            row.append(row_sum)
        result.append(row)
    return result

def rotate_and_transform(matrix):
    rotated_matrix = rotate_matrix_90(matrix)
    transformed_matrix = sum_matrix(rotated_matrix)
    return transformed_matrix

Explanation: The matrix is first rotated, and then each element is replaced by the sum of its row and column (excluding itself).

Question 8: Time Check

import pandas as pd

def check_time_coverage(df):
    df['timestamp'] = pd.to_datetime(df['timestamp'])
    df['day_of_week'] = df['timestamp'].dt.day_name()
    df['time_of_day'] = df['timestamp'].dt.time
    
    # Group by (id, id_2) and check if all 7 days and full 24 hours are covered
    def is_complete(group):
        days = group['day_of_week'].nunique() == 7
        # Check if each day covers the full 24 hours
        hours = group['time_of_day'].min() == pd.Timestamp('00:00:00').time() and group['time_of_day'].max() == pd.Timestamp('23:59:59').time()
        return days and hours
    
    return df.groupby(['id', 'id_2']).apply(is_complete)

Explanation: The function groups by (id, id_2) and checks if all 7 days and a full 24-hour range are present.


Python Section 2

Question 9: Distance Matrix Calculation

import pandas as pd
import numpy as np

def calculate_distance_matrix(df):
    # Initialize the distance matrix with zeros
    locations = df['id'].unique()
    distance_matrix = pd.DataFrame(np.zeros((len(locations), len(locations))), index=locations, columns=locations)
    
    # Fill in the distance matrix with cumulative distances
    for i, row in df.iterrows():
        id_start = row['id_start']
        id_end = row['id_end']
        distance = row['distance']
        distance_matrix.loc[id_start, id_end] = distance
        distance_matrix.loc[id_end, id_start] = distance  # Make sure it's symmetric
    
    # Make diagonal values 0 (distances from a location to itself)
    np.fill_diagonal(distance_matrix.values, 0)
    
    return distance_matrix

Explanation: This function builds a symmetric matrix where distances between IDs are cumulative. Diagonal values are set to zero.

Question 10: Unroll Distance Matrix

def unroll_distance_matrix(df):
    unrolled_data = []
    for id_start in df.index:
        for id_end in df.columns:
            if id_start != id_end:
                distance = df.loc[id_start, id_end]
                unrolled_data.append([id_start, id_end, distance])
    
    # Create the resulting DataFrame
    unrolled_df = pd.DataFrame(unrolled_data, columns=['id_start', 'id_end', 'distance'])
    return unrolled_df

Explanation: This function generates a DataFrame that contains the start and end IDs, along with the corresponding distance from the matrix. The diagonal values are excluded (i.e., distances from a location to itself).

Question 11: Finding IDs within Percentage Threshold

def find_ids_within_ten_percentage_threshold(df, reference_id):
    # Filter the rows where id_start equals the reference value
    reference_rows = df[df['id_start'] == reference_id]
    
    # Calculate the average distance for the reference value
    avg_distance = reference_rows['distance'].mean()
    
    # Define the 10% threshold range
    lower_bound = avg_distance * 0.9
    upper_bound = avg_distance * 1.1
    
    # Find the ids within the 10% threshold range
    ids_within_threshold = df[(df['distance'] >= lower_bound) & (df['distance'] <= upper_bound)]['id_start'].unique()
    
    # Sort the ids and return them as a list
    return sorted(ids_within_threshold)

Explanation: This function calculates the average distance for a specific id_start, finds IDs whose distances are within 10% of this average, and returns them in a sorted list.

Question 12: Calculate Toll Rate

def calculate_toll_rate(df):
    # Define rate coefficients for different vehicle types
    rate_coefficients = {
        'moto': 0.8,
        'car': 1.2,
        'rv': 1.5,
        'bus': 2.2,
        'truck': 3.6
    }
    
    # Add columns for each vehicle type by multiplying distance by the rate coefficients
    for vehicle, coefficient in rate_coefficients.items():
        df[vehicle] = df['distance'] * coefficient
    
    return df

Explanation: The function calculates toll rates for different vehicle types by multiplying the distance with predefined rate coefficients. It adds new columns for each vehicle type in the DataFrame.

Question 13: Calculate Time-Based Toll Rates

import datetime as dt

def calculate_time_based_toll_rates(df):
    # Define discount factors for weekdays and weekends
    weekday_discounts = {
        (dt.time(0, 0), dt.time(10, 0)): 0.8,
        (dt.time(10, 0), dt.time(18, 0)): 1.2,
        (dt.time(18, 0), dt.time(23, 59, 59)): 0.8
    }
    weekend_discount = 0.7
    
    # Add columns for start_day, start_time, end_day, end_time
    df['start_day'] = 'Monday'  # For simplicity, assuming constant values (update logic as per real data)
    df['end_day'] = 'Sunday'  # For simplicity, assuming constant values (update logic as per real data)
    df['start_time'] = dt.time(0, 0)  # Update as per real data
    df['end_time'] = dt.time(23, 59, 59)  # Update as per real data
    
    # Apply discount factors based on the day of the week and time intervals
    def apply_discount(row, discount):
        for vehicle in ['moto', 'car', 'rv', 'bus', 'truck']:
            row[vehicle] *= discount
        return row
    
    for i, row in df.iterrows():
        start_time = row['start_time']
        end_time = row['end_time']
        
        # Check if it's a weekend
        if row['start_day'] in ['Saturday', 'Sunday']:
            df.iloc[i] = apply_discount(row, weekend_discount)
        else:
            # Apply weekday discounts based on time intervals
            for time_range, discount in weekday_discounts.items():
                if time_range[0] <= start_time < time_range[1]:
                    df.iloc[i] = apply_discount(row, discount)
    
    return df

Explanation: The function calculates toll rates based on the time of day and day of the week. It applies different discount factors depending on whether it's a weekday or weekend, and what time of day it is, covering all 7 days and a full 24-hour period.
